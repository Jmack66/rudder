import re
import json
from typing import Dict, Any

class GCodeParser:
    def __init__(self):
        self.parameters = {}
        self.layer_count = 0
        self.filament_used = 0
        self.print_time = 0
        self.bed_temperature = None
        self.extruder_temperature = None
        self.fan_speed = None
        self.layer_height = None
        self.print_speed = None
        self.retraction_distance = None
        self.retraction_speed = None
        # New parameters
        self.nozzle_diameter = None
        self.filament_diameter = None
        self.infill_percentage = None
        self.acceleration = None
        self.jerk = None
        self.initial_layer_height = None
        self.first_layer_temperature = None
        self.slicer = None
        self.object_dimensions = None
        self.perimeters = None
        self.top_layers = None
        self.bottom_layers = None
        self.shell_thickness = None
        self.support_material = None
        self.gcode_flavor = None
        self.all_slicer_params = {}

    def parse_file(self, file_path: str) -> Dict[str, Any]:
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()
            header = self._extract_header(lines)
            self.slicer = self._detect_slicer(header)
            if self.slicer == 'PrusaSlicer':
                self._parse_prusaslicer(header)
                self._parse_prusaslicer_config_block(lines)
            elif self.slicer == 'SuperSlicer':
                self._parse_superslicer(header, lines)
            elif self.slicer == 'Cura':
                self._parse_cura(header)
            elif self.slicer == 'Bambu Studio':
                self._parse_bambu(header)
            else:
                self._parse_generic(header)
            return {
                'slicer': self.slicer,
                'all_slicer_params': self.all_slicer_params
            }
        except Exception as e:
            print(f"Error parsing GCode file: {e}")
            return {}

    def _extract_header(self, lines):
        header = []
        for line in lines:
            stripped = line.strip()
            if stripped.startswith(';') or stripped == '':
                header.append(line.rstrip('\n'))
            elif re.match(r'^[GMT]\d+', stripped):  # Stop at first G/M code
                break
            else:
                header.append(line.rstrip('\n'))
        return header

    def _detect_slicer(self, header):
        for line in header:
            if 'generated by PrusaSlicer' in line:
                return 'PrusaSlicer'
            if 'generated by SuperSlicer' in line:
                return 'SuperSlicer'
            if 'generated by Cura_SteamEngine' in line or 'Cura_SteamEngine' in line:
                return 'Cura'
            if 'Bambu Studio' in line:
                return 'Bambu Studio'
        return 'Unknown'

    def _parse_prusaslicer(self, header):
        for line in header:
            m_eq = re.match(r';\s*([^=]+?)\s*=\s*(.+)', line)
            m_colon = re.match(r';\s*([^:]+?)\s*:\s*(.+)', line)
            if m_eq:
                key = m_eq.group(1).strip()
                value = m_eq.group(2).strip()
                self.all_slicer_params[key] = value
            elif m_colon:
                key = m_colon.group(1).strip()
                value = m_colon.group(2).strip()
                self.all_slicer_params[key] = value

    def _parse_prusaslicer_config_block(self, lines):
        in_block = False
        for line in lines:
            if line.strip().startswith('; prusaslicer_config = begin'):
                in_block = True
                continue
            if line.strip().startswith('; prusaslicer_config = end'):
                break
            if in_block:
                m_eq = re.match(r';\s*([^=]+?)\s*=\s*(.*)', line)
                if m_eq:
                    key = m_eq.group(1).strip()
                    value = m_eq.group(2).strip()
                    self.all_slicer_params[key] = value

    def _parse_superslicer(self, header, lines):
        """Parse SuperSlicer parameters from header and end configuration block."""
        # Parse header parameters (similar to PrusaSlicer)
        for line in header:
            m_eq = re.match(r';\s*([^=]+?)\s*=\s*(.+)', line)
            m_colon = re.match(r';\s*([^:]+?)\s*:\s*(.+)', line)
            if m_eq:
                key = m_eq.group(1).strip()
                value = m_eq.group(2).strip()
                self.all_slicer_params[key] = value
            elif m_colon:
                key = m_colon.group(1).strip()
                value = m_colon.group(2).strip()
                self.all_slicer_params[key] = value

        # Parse end configuration block (SuperSlicer stores config at end)
        in_config = False
        config_started = False

        # Scan from the end of the file backwards to find configuration
        for i in range(len(lines) - 1, -1, -1):
            line = lines[i].strip()

            # Look for end marker
            if line == '; SuperSlicer_config = end':
                in_config = True
                continue

            # If we're in config and hit the beginning, break
            if in_config and (line.startswith(';LAYER:') or
                             line.startswith('G') or line.startswith('M') or
                             (line.startswith(';') and 'generated by SuperSlicer' in line)):
                break

            # Parse configuration parameters
            if in_config and line.startswith(';'):
                m_eq = re.match(r';\s*([^=]+?)\s*=\s*(.*)', line)
                if m_eq:
                    key = m_eq.group(1).strip()
                    value = m_eq.group(2).strip()
                    self.all_slicer_params[key] = value

    def _parse_cura(self, header):
        for line in header:
            # Cura: ;SETTING_3 ... or ; key value
            if line.startswith(';SETTING_3 '):
                # These are base64-encoded, can be decoded for advanced use
                continue
            m_space = re.match(r';\s*([^:=]+?)\s+(.+)', line)
            if m_space:
                key = m_space.group(1).strip()
                value = m_space.group(2).strip()
                self.all_slicer_params[key] = value

    def _parse_bambu(self, header):
        # Look for JSON block in comments
        json_lines = []
        in_json = False
        for line in header:
            if line.startswith(';') and '{' in line:
                in_json = True
            if in_json:
                json_lines.append(line.lstrip(';').strip())
                if '}' in line:
                    break
        if json_lines:
            try:
                json_str = '\n'.join(json_lines)
                params = json.loads(json_str)
                for k, v in params.items():
                    self.all_slicer_params[k] = v
            except Exception:
                pass
        # Fallback: also parse ; key = value
        for line in header:
            m_eq = re.match(r';\s*([^:=]+?)\s*=\s*(.+)', line)
            if m_eq:
                key = m_eq.group(1).strip()
                value = m_eq.group(2).strip()
                self.all_slicer_params[key] = value

    def _parse_generic(self, header):
        for line in header:
            m_eq = re.match(r';\s*([^:=]+?)\s*=\s*(.+)', line)
            m_colon = re.match(r';\s*([^:=]+?)\s*:\s*(.+)', line)
            m_space = re.match(r';\s*([^:=]+?)\s+(.+)', line)
            if m_eq:
                key = m_eq.group(1).strip()
                value = m_eq.group(2).strip()
                self.all_slicer_params[key] = value
            elif m_colon:
                key = m_colon.group(1).strip()
                value = m_colon.group(2).strip()
                self.all_slicer_params[key] = value
            elif m_space:
                key = m_space.group(1).strip()
                value = m_space.group(2).strip()
                self.all_slicer_params[key] = value

    def _extract_temperatures(self, content: str):
        """Extract temperature settings from GCode."""
        # Bed temperature
        bed_temp = re.search(r'M140 S(\d+)', content)
        if bed_temp:
            self.bed_temperature = float(bed_temp.group(1))

        # Extruder temperature
        extruder_temp = re.search(r'M104 S(\d+)', content)
        if extruder_temp:
            self.extruder_temperature = float(extruder_temp.group(1))

    def _extract_speeds(self, content: str):
        """Extract speed settings from GCode."""
        # Fan speed
        fan_speed = re.search(r'M106 S(\d+)', content)
        if fan_speed:
            self.fan_speed = float(fan_speed.group(1)) / 255 * 100  # Convert to percentage

        # Print speed
        print_speed = re.search(r'M220 S(\d+)', content)
        if print_speed:
            self.print_speed = float(print_speed.group(1))

    def _extract_retraction(self, content: str):
        """Extract retraction settings from GCode."""
        # Retraction distance
        retraction_dist = re.search(r'M207 S(\d+\.?\d*)', content)
        if retraction_dist:
            self.retraction_distance = float(retraction_dist.group(1))

        # Retraction speed
        retraction_speed = re.search(r'M207 F(\d+)', content)
        if retraction_speed:
            self.retraction_speed = float(retraction_speed.group(1))

    def _extract_layer_info(self, content: str):
        """Extract layer information from GCode."""
        # Layer height
        layer_height = re.search(r'layer_height = (\d+\.?\d*)', content)
        if layer_height:
            self.layer_height = float(layer_height.group(1))

        # Count layers
        self.layer_count = len(re.findall(r';LAYER:', content))

    def _extract_filament_usage(self, content: str):
        """Extract filament usage information from GCode."""
        # Filament used
        filament_used = re.search(r'filament used \[mm\] = (\d+\.?\d*)', content)
        if filament_used:
            self.filament_used = float(filament_used.group(1))

        # Print time
        print_time = re.search(r'estimated printing time \(normal mode\) = (\d+\.?\d*)', content)
        if print_time:
            self.print_time = float(print_time.group(1))

    def _extract_slicer_parameters(self, content: str):
        # Slicer name/version
        slicer = re.search(r'; generated by (.+)', content, re.IGNORECASE)
        if slicer:
            self.slicer = slicer.group(1).strip()
        # GCode flavor
        flavor = re.search(r'; G-code flavor: (.+)', content, re.IGNORECASE)
        if flavor:
            self.gcode_flavor = flavor.group(1).strip()
        # Nozzle diameter
        nozzle = re.search(r'; nozzle_diameter = ([\d.]+)', content)
        if nozzle:
            self.nozzle_diameter = float(nozzle.group(1))
        # Filament diameter
        filament = re.search(r'; filament_diameter = ([\d.]+)', content)
        if filament:
            self.filament_diameter = float(filament.group(1))
        # Infill percentage
        infill = re.search(r'; infill_density = ([\d.]+)', content)
        if infill:
            self.infill_percentage = float(infill.group(1))
        # Acceleration
        accel = re.search(r'M204 S([\d.]+)', content)
        if accel:
            self.acceleration = float(accel.group(1))
        # Jerk
        jerk = re.search(r'M205 X([\d.]+)', content)
        if jerk:
            self.jerk = float(jerk.group(1))
        # Initial layer height
        ilh = re.search(r'; initial_layer_height = ([\d.]+)', content)
        if ilh:
            self.initial_layer_height = float(ilh.group(1))
        # First layer temperature
        flt = re.search(r'; first_layer_temperature = ([\d.]+)', content)
        if flt:
            self.first_layer_temperature = float(flt.group(1))
        # Object dimensions (if available)
        dims = re.search(r'; object_dimensions = ([\d.x ]+)', content)
        if dims:
            self.object_dimensions = dims.group(1).strip()
        # Perimeters/walls
        perim = re.search(r'; perimeters = (\d+)', content)
        if perim:
            self.perimeters = int(perim.group(1))
        # Top layers
        top = re.search(r'; top_layers = (\d+)', content)
        if top:
            self.top_layers = int(top.group(1))
        # Bottom layers
        bottom = re.search(r'; bottom_layers = (\d+)', content)
        if bottom:
            self.bottom_layers = int(bottom.group(1))
        # Shell thickness
        shell = re.search(r'; shell_thickness = ([\d.]+)', content)
        if shell:
            self.shell_thickness = float(shell.group(1))
        # Support material
        support = re.search(r'; support_material = (yes|no)', content, re.IGNORECASE)
        if support:
            self.support_material = support.group(1).strip().lower() == 'yes'

    def _extract_all_slicer_params(self, content: str):
        """Extract all key-value pairs from GCode comments."""
        self.all_slicer_params = {}
        for line in content.splitlines():
            if line.startswith(';'):
                # Match ; key = value
                m_eq = re.match(r';\s*([^:=]+?)\s*=\s*(.+)', line)
                if m_eq:
                    key = m_eq.group(1).strip()
                    value = m_eq.group(2).strip()
                    self.all_slicer_params[key] = value
                    continue
                # Match ; key: value
                m_colon = re.match(r';\s*([^:=]+?)\s*:\s*(.+)', line)
                if m_colon:
                    key = m_colon.group(1).strip()
                    value = m_colon.group(2).strip()
                    self.all_slicer_params[key] = value
            # Stop after the initial header (optional: break at first G1/G0 command)
            if line and not line.startswith(';'):
                break
